@Parser Implicit;
@Behaviour NortonDruckerPrager;
@Algorithm NewtonRaphson_NumericalJacobian;
@Theta 1.;
@Epsilon 1.e-14;
@Parameter local_zero_tolerance = 1.e-14;

// Intercept of yield function
@MaterialProperty real K;
K.setEntryName("Cohesion");
// coefficient of I1 in yield function
@MaterialProperty real alpha_y;
alpha_y.setEntryName("FrictionParameter");
@MaterialProperty real young;
young.setGlossaryName("YoungModulus");
@MaterialProperty real nu;
nu.setGlossaryName("PoissonRatio");
@MaterialProperty thermalexpansion alpha;
alpha.setGlossaryName("ThermalExpansion");
@MaterialProperty real Qact;
@MaterialProperty real A_creep;
@MaterialProperty real n_creep;

@StateVariable strain lam;
lam.setGlossaryName("EquivalentPlasticStrain");
@StateVariable real vp;

@LocalVariable stress lambda;
@LocalVariable stress mu;
@LocalVariable stress Fel;
@LocalVariable StressStensor s0;

// @Parameter Tref;
// Tref.setDefaultValue(293.15);

@InitLocalVariables {
  real y2;
  if ((T-273.15)<400.0){
  y2 = El_1 * power<2>(400.0) + El_2 * 400.0 + El_3;  
  }else{
  y2 = El_1 * power<2>(T-273.15) + El_2 * (T-273.15) + El_3;
  }
  
  lambda = computeLambda(young * y2, nu);
  mu = computeMu(young * y2, nu);
  StressStensor sigel(lambda * trace(eel + deto) * Stensor::Id() +
                      2 * mu * (eel + deto)); // StresssStensor in Tutorial

  const auto I1_el = trace(sigel);
  const auto s_el = deviator(sigel);
  const auto J2_el = max((s_el | s_el) / 2., local_zero_tolerance);
  const auto sqrt_J2_el = sqrt(J2_el);

  // J2 = (s_dev|s_dev)/2.; //defines double contraction
  Fel = alpha_y * I1_el + sqrt_J2_el - K > 0.;
  
}

@ComputeStress {
  sig = (lambda * trace(eel) * Stensor::Id() + 2 * mu * eel);
}

@Integrator {
  constexpr const auto id = Stensor::Id();
  constexpr const auto id4 = Stensor4::Id();
  const auto Pdev = id4 - (id ^ id) / 3;
  
  Stensor nvp = Stensor(0.);
  Stensor s_dev = deviator(sig);
  const stress seq = sigmaeq(s_dev);

  if (seq > 1.e-15) {
    nvp = 1.5 * s_dev / seq;
  }
  fvp -= dt * A_creep * exp(-Qact / 8.3144598 / (T)) * pow(seq, n_creep);

  if (Fel > 0) {

        const auto I1 = trace(sig);
        const auto s = deviator(sig);
        const auto J2 = max((s | s) / 2., local_zero_tolerance);
        const auto sqrt_J2 = sqrt(J2);
        const auto i_sqrt_J2 = 1. / sqrt_J2;
        // yield function
        const auto Fy = alpha_y * I1 + sqrt_J2 - K;

        // flow direction
        const auto n = eval(alpha_g * id + s * i_sqrt_J2 / 2.);

        // yield function gradient
        const auto nF = eval(alpha_y * id + s * i_sqrt_J2 / 2.);
        const auto dn_dsig =
            eval(i_sqrt_J2 / 2. * (id4 - (s ^ s) / (2. * J2)) * Pdev);

        // residuals
        //feel += dlam * n;
        feel =deel - deto + dlam * n + dvp * nvp;
        flam = Fy / D(0, 0);

  } else {
    feel = deel - deto + dvp * nvp;
  }
}

@TangentOperator {
  if ((smt == ELASTIC) ) {
    computeElasticStiffness<N, Type>::exe(Dt, lambda, mu);
  } else  {
    StiffnessTensor De;
    Stensor4 Je;
    computeElasticStiffness<N, Type>::exe(De, lambda, mu);
    getPartialJacobianInvert(Je);
    Dt = De * Je;
  } 
}
